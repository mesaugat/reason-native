(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{107:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return r})),n.d(t,"default",(function(){return p}));var a=n(1),o=(n(0),n(121));const c={id:"expect",title:"Expect"},l={id:"rely/expect",title:"Expect",description:'When you\'re writing tests, you often need to check that values meet certain conditions. Expect gives you access to a number of "matchers" that let you validate different things.',source:"@site/../docs/rely/expect.md",permalink:"/docs/rely/expect",sidebar:"docs",previous:{title:"Basic API",permalink:"/docs/rely/api"},next:{title:"Advanced Topics - Rely",permalink:"/docs/rely/advanced"}},r=[{value:"<code>expect.array</code>",id:"expectarray",children:[{value:"<code>expect.array(array(&#39;a)).toBeEmpty()</code>",id:"expectarrayarrayatobeempty",children:[]},{value:"<code>expect.array(array(&#39;a)).toContain(&#39;a)</code>",id:"expectarrayarrayatocontaina",children:[]},{value:"<code>expect.array(array(&#39;a)).toContainEqual(~equals:(&#39;a, &#39;a) =&gt; bool=?, &#39;a)</code>",id:"expectarrayarrayatocontainequalequalsa-a--bool-a",children:[]},{value:"<code>expect.array(array(&#39;a)).toEqual(~equals:(&#39;a, &#39;a) =&gt; bool, array(&#39;a))</code>",id:"expectarrayarrayatoequalequalsa-a--bool-arraya",children:[]}]},{value:"<code>expect.assertions</code> (as of Rely 3.1.0)",id:"expectassertions-as-of-rely-310",children:[{value:"<code>expect.assertions(int)</code>",id:"expectassertionsint",children:[]},{value:"<code>expect.hasAssertions()</code>",id:"expecthasassertions",children:[]}]},{value:"<code>expect.bool</code>",id:"expectbool",children:[{value:"<code>expect.bool(bool).toBe(bool)</code>",id:"expectboolbooltobebool",children:[]},{value:"<code>expect.bool(bool).toBeTrue()</code>",id:"expectboolbooltobetrue",children:[]},{value:"<code>expect.bool(bool).toBeFalse()</code>",id:"expectboolbooltobefalse",children:[]}]},{value:"<code>expect.equal</code>",id:"expectequal",children:[{value:"<code>expect.equal(~equals: (&#39;a, &#39;a) =&gt; bool=?, &#39;a, &#39;a)</code>",id:"expectequalequals-a-a--bool-a-a",children:[]}]},{value:"<code>expect.ext</code>",id:"expectext",children:[{value:"<code>expect.ext</code>",id:"expectext-1",children:[]}]},{value:"<code>expect.file</code>",id:"expectfile",children:[{value:"<code>expect.file(string).toBeEmpty()</code>",id:"expectfilestringtobeempty",children:[]},{value:"<code>expect.file(string).toEqual(string)</code>",id:"expectfilestringtoequalstring",children:[]},{value:"<code>expect.file(string).toEqualFile(string)</code>",id:"expectfilestringtoequalfilestring",children:[]},{value:"<code>expect.file(string).toEqualLines(list(string))</code>",id:"expectfilestringtoequallinesliststring",children:[]},{value:"<code>expect.file(string).toMatch(string)</code>",id:"expectfilestringtomatchstring",children:[]},{value:"<code>expect.file(string).toMatchSnapshot()</code>",id:"expectfilestringtomatchsnapshot",children:[]}]},{value:"<code>expect.float</code>",id:"expectfloat",children:[{value:"<code>expect.float(float).toBeCloseTo(~digits: int=?, float)</code>",id:"expectfloatfloattobeclosetodigits-int-float",children:[]}]},{value:"<code>expect.fn</code>",id:"expectfn",children:[{value:"<code>expect.fn(unit =&gt; &#39;a).toThrow()</code>",id:"expectfnunit--atothrow",children:[]},{value:"<code>expect.fn(unit =&gt; &#39;a).toThrowException(exn)</code>",id:"expectfnunit--atothrowexceptionexn",children:[]}]},{value:"<code>expect.int</code>",id:"expectint",children:[{value:"<code>expect.int(int).toBe(int)</code>",id:"expectintinttobeint",children:[]}]},{value:"<code>expect.lines</code>",id:"expectlines",children:[{value:"<code>expect.lines(list(string)).toBeEmpty()</code>",id:"expectlinesliststringtobeempty",children:[]},{value:"<code>expect.lines(list(string)).toEqual(string)</code>",id:"expectlinesliststringtoequalstring",children:[]},{value:"<code>expect.lines(list(string)).toEqualFile(string)</code>",id:"expectlinesliststringtoequalfilestring",children:[]},{value:"<code>expect.lines(list(string)).toEqualLines(list(string))</code>",id:"expectlinesliststringtoequallinesliststring",children:[]},{value:"<code>expect.lines(list(string)).toMatch(string)</code>",id:"expectlinesliststringtomatchstring",children:[]},{value:"<code>expect.lines(list(string)).toMatchSnapshot()</code>",id:"expectlinesliststringtomatchsnapshot",children:[]}]},{value:"<code>expect.list</code>",id:"expectlist",children:[{value:"<code>expect.list(list(&#39;a)).toBeEmpty()</code>",id:"expectlistlistatobeempty",children:[]},{value:"<code>expect.list(list(&#39;a)).toContain(&#39;a)</code>",id:"expectlistlistatocontaina",children:[]},{value:"<code>expect.list(list(&#39;a)).toContainEqual(~equals:(&#39;a, &#39;a) =&gt; bool=?, &#39;a)</code>",id:"expectlistlistatocontainequalequalsa-a--bool-a",children:[]},{value:"<code>expect.list(actual).toEqual(~equals, expected)</code>",id:"expectlistactualtoequalequals-expected",children:[]}]},{value:"<code>expect.mock</code>",id:"expectmock",children:[{value:"<code>expect.mock(mock).lastCalledWith(&#39;args)</code>",id:"expectmockmocklastcalledwithargs",children:[]},{value:"<code>expect.mock(mock).lastReturnedWith(&#39;ret)</code>",id:"expectmockmocklastreturnedwithret",children:[]},{value:"<code>expect.mock(mock).nthCalledWith(~equals:(&#39;args, &#39;args) =&gt; bool=?, int, &#39;args)</code>",id:"expectmockmocknthcalledwithequalsargs-args--bool-int-args",children:[]},{value:"<code>expect.mock(mock).nthReturnedWith(~equals:(&#39;ret, &#39;ret) =&gt; bool=?, int, &#39;args)</code>",id:"expectmockmocknthreturnedwithequalsret-ret--bool-int-args",children:[]},{value:"<code>expect.mock(mock).toBeCalled()</code>",id:"expectmockmocktobecalled",children:[]},{value:"<code>expect.mock(mock).toBeCalledTimes(int)</code>",id:"expectmockmocktobecalledtimesint",children:[]},{value:"<code>expect.mock(mock).toBeCalledWith(~equals: (&#39;args, &#39;args) =&gt; bool=?, &#39;args)</code>",id:"expectmockmocktobecalledwithequals-args-args--bool-args",children:[]},{value:"<code>expect.mock(mock).toThrow()</code>",id:"expectmockmocktothrow",children:[]},{value:"<code>expect.mock(mock).toThrowException(exn)</code>",id:"expectmockmocktothrowexceptionexn",children:[]},{value:"<code>expect.mock(mock).toReturnTimes(int)</code>",id:"expectmockmocktoreturntimesint",children:[]},{value:"<code>expect.mock(mock).toReturnWith(~equals: (&#39;ret, &#39;ret) =&gt; bool=?, &#39;ret)</code>",id:"expectmockmocktoreturnwithequals-ret-ret--bool-ret",children:[]}]},{value:"<code>expect.option</code>",id:"expectoption",children:[{value:"<code>expect.option(&#39;a).toBe(~equals: (&#39;a, &#39;a) =&gt; bool=?, option(&#39;a))</code>",id:"expectoptionatobeequals-a-a--bool-optiona",children:[]},{value:"<code>expect.option(option(&#39;a)).toBeNone()</code>",id:"expectoptionoptionatobenone",children:[]},{value:"<code>expect.option(option(&#39;a)).toBeSome()</code>",id:"expectoptionoptionatobesome",children:[]}]},{value:"<code>expect.result</code>",id:"expectresult",children:[{value:"<code>expect.result(result(&#39;a)).toBe(~equalsOk: (&#39;a, &#39;a) =&gt; bool=?, ~equalsError: (&#39;b, &#39;b) =&gt; bool =?, result(&#39;a))</code>",id:"expectresultresultatobeequalsok-a-a--bool-equalserror-b-b--bool--resulta",children:[]},{value:"<code>expect.result(result(&#39;a)).toBeOk()</code>",id:"expectresultresultatobeok",children:[]},{value:"<code>expect.result(result(&#39;a)).toBeError()</code>",id:"expectresultresultatobeerror",children:[]}]},{value:"<code>expect.same</code>",id:"expectsame",children:[{value:"<code>expect.same(&#39;a, &#39;a)</code>",id:"expectsamea-a",children:[]},{value:"<code>expect.notSame(&#39;a, &#39;a)</code>",id:"expectnotsamea-a",children:[]}]},{value:"<code>expect.string</code>",id:"expectstring",children:[{value:"<code>expect.string(string).toBeEmpty()</code>",id:"expectstringstringtobeempty",children:[]},{value:"<code>expect.string(string).toEqual(string)</code>",id:"expectstringstringtoequalstring",children:[]},{value:"<code>expect.string(string).toEqualFile(string)</code>",id:"expectstringstringtoequalfilestring",children:[]},{value:"<code>expect.string(string).toEqualLines(list(string))</code>",id:"expectstringstringtoequallinesliststring",children:[]},{value:"<code>expect.string(string).toMatch(string)</code>",id:"expectstringstringtomatchstring",children:[]},{value:"<code>expect.string(string).toMatchSnapshot()</code>",id:"expectstringstringtomatchsnapshot",children:[]}]}],i={rightToc:r},s="wrapper";function p({components:e,...t}){return Object(o.b)(s,Object(a.a)({},i,t,{components:e,mdxType:"MDXLayout"}),Object(o.b)("p",null,'When you\'re writing tests, you often need to check that values meet certain conditions. Expect gives you access to a number of "matchers" that let you validate different things.'),Object(o.b)("p",null,"Virtually all matchers below are negatable via prepending ",Object(o.b)("inlineCode",{parentName:"p"},".not")," after the type (e.g. ",Object(o.b)("inlineCode",{parentName:"p"},"expect.string(actual).not.toBeEmpty()"),", ",Object(o.b)("inlineCode",{parentName:"p"},"expect.int(actual).not.toBe(42)"),"). Matchers that are not negatable will be explicitly called out in the documentation below."),Object(o.b)("p",null,"<AUTOGENERATED_TABLE_OF_CONTENTS>"),Object(o.b)("h2",{id:"expectarray"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.array")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type equalsFn('a) = ('a, 'a) => bool;\n\ntype arrayMatchers('a) = {\n  toEqual: (~equals: equalsFn('a)=?, array('a)) => unit,\n  toBeEmpty: unit => unit,\n  toContain: 'a => unit,\n  toContainEqual: (~equals: equalsFn('a)=?, 'a) => unit,\n};\n\ntype arrayMatchersWithNot('a) = {\n  not: arrayMatchers('a),\n  toEqual: (~equals: equalsFn('a)=?, array('a)) => unit,\n  toBeEmpty: unit => unit,\n  toContain: 'a => unit,\n  toContainEqual: (~equals: equalsFn('a)=?, 'a) => unit,\n};\n\nlet expect: {\n  ...\n  array: 'a. array('a) => arrayMatchersWithNot('a)\n  ...\n};\n")),Object(o.b)("h3",{id:"expectarrayarrayatobeempty"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.array(array('a)).toBeEmpty()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.array(expected).toBeEmpty()")," to check that an array is empty."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.array.toBeEmpty", ({test}) => {\n  test("Empty array should be empty", ({expect}) => {\n    expect.array([||]).toBeEmpty();\n  });\n});\n')),Object(o.b)("h3",{id:"expectarrayarrayatocontaina"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.array(array('a)).toContain('a)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.array(actual).toContain(expected)")," when you want to check that an item is in an array. For testing items in the array, this uses ",Object(o.b)("inlineCode",{parentName:"p"},"==="),", a physical equality check."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Array example", ({test}) => {\n  test("should contain", ({expect}) => {\n    expect.array([|1, 2, 3|]).toContain(2);\n  });\n});\n')),Object(o.b)("h3",{id:"expectarrayarrayatocontainequalequalsa-a--bool-a"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.array(array('a)).toContainEqual(~equals:('a, 'a) => bool=?, 'a)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.array(actual).toContainEqual(~equals=?, expected)")," when you want to check that an item is in an array. For testing items in the array, this uses ",Object(o.b)("inlineCode",{parentName:"p"},"==")," a structural equality check."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ntype insect = {\n  name: string,\n  numberOfLegs: int,\n};\n\ndescribe("Array example", ({test}) => {\n  test("contain equal", ({expect}) => {\n    expect.array(getInsects()).toContainEqual({\n      name: "centipede",\n      numberOfLegs: 100,\n    });\n  });\n});\n')),Object(o.b)("p",null,"Comparing types that need a custom comparator (such as floats) can be done using ",Object(o.b)("inlineCode",{parentName:"p"},"expect.array(actual).toContainEqual(~equals, expected)"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\nlet equals = (f1, f2) => abs_float(f1 -. f2) < 0.1;\n\ndescribe("Array example", ({test}) => {\n  test("contain equal", ({expect}) => {\n    expect.array([|1., 2., 3.|]).toContainEqual(~equals, 0.99);\n  });\n});\n')),Object(o.b)("h3",{id:"expectarrayarrayatoequalequalsa-a--bool-arraya"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.array(array('a)).toEqual(~equals:('a, 'a) => bool, array('a))")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.array(actual).toEqual(~equals=?, expected)")," to check that an array is equal to another array."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Array example", ({test}) => {\n  test("array equality", ({expect}) => {\n    expect.array(countToThree()).toEqual([|1, 2, 3|]);\n  });\n});\n')),Object(o.b)("p",null,"Comparing arrays of types that need a custom comparator (such as floats) can also be done."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\nlet equals = (f1, f2) => abs_float(f1 -. f2) < 0.1;\n\ndescribe("Array example", ({test}) => {\n  test("toEqual with custom comparator", ({expect}) => {\n    expect.array(countToThreeWithFloats()).toEqual(~equals, [|1., 2., 3.|]);\n  });\n});\n')),Object(o.b)("h2",{id:"expectassertions-as-of-rely-310"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.assertions")," (as of Rely 3.1.0)"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"let expect: {\n  ...\n  assertions: int => bool,\n  hasAssertions: unit => unit,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectassertionsint"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.assertions(int)")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"expect.assertions(int)")," verifies that a certain number of assertions are called during a test. This is often useful when testing code with callbacks, in order to make sure that assertions in a callback actually got called."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.assertions", ({test}) => {\n  test("doSomething calls both callbacks", ({expect}) => {\n    let callback1 = () => expect.bool(true).toBeTrue();\n    let callback2 = () => expect.bool(true).not.toBeFalse();\n\n    doSomething(callback1, callback2);\n\n    /* this line can be anywhere inside the function body, if there are multiple\n     * calls to expect.assertions, the last one takes precedence */\n    expect.assertions(2);\n  });\n});\n')),Object(o.b)("h3",{id:"expecthasassertions"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.hasAssertions()")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"expect.hasAssertions()")," verifies that at least one assertion is called during a test. This is often useful when testing code with callbacks, in order to make sure that assertions in a callback actually got called."),Object(o.b)("p",null,"Suppose you have an application that allows for side effects to be dispatched on changes to its state via a callback. We could also use such a feature to test that all state changes in a certain path are valid by making an assertion inside that callback. If we want to do that and also ensure that at least one state change took place, we could write the following code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.hasAssertions", ({test}) => {\n  test("our callback gets called", ({expect}) => {\n    let validateState = (state) => expect.bool(true).toBeTrue();\n\n    App.run(validateState);\n\n    /* this line can be anywhere inside the function body, if there are multiple\n     * calls to expect.assertions, the last one takes precedence */\n    expect.hasAssertions();\n  });\n});\n')),Object(o.b)("h2",{id:"expectbool"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.bool")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type boolMatchers = {\n  toBe: bool => unit,\n  toBeTrue: unit => unit,\n  toBeFalse: unit => unit,\n};\ntype boolMatchersWithNot = {\n  not: boolMatchers,\n  toBe: bool => unit,\n  toBeTrue: unit => unit,\n  toBeFalse: unit => unit,\n};\n\nlet expect: {\n  ...\n  bool: bool => boolMatchersWithNot\n  ...\n};\n")),Object(o.b)("h3",{id:"expectboolbooltobebool"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.bool(bool).toBe(bool)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.bool(actual).toBe(expected)")," to check that a boolean value is equal to a particular boolean value."),Object(o.b)("p",null,"For example this can be useful when writing tests inside of a ",Object(o.b)("inlineCode",{parentName:"p"},"List.map")," statement."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.bool", ({test}) => {\n  let _ =\n    List.map(\n      ((testName, food, expected)) =>\n        test(testName, ({expect}) =>\n          expect.bool(isDelicious(food)).toBe(expected)\n        ),\n      [("expect bacon to be delicious", "bacon", true)],\n    );\n  ();\n});\n')),Object(o.b)("h3",{id:"expectboolbooltobetrue"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.bool(bool).toBeTrue()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.bool(actual).toBeTrue()")," to check that a boolean value is equal to true."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.bool", ({test}) => {\n  test("expect bacon to be delicious", ({expect}) => {\n    expect.bool(isDelicious("bacon")).toBeTrue();\n  });\n});\n')),Object(o.b)("h3",{id:"expectboolbooltobefalse"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.bool(bool).toBeFalse()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.bool(actual).toBeFalse()")," to check that a boolean value is equal to false."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.bool", ({test}) => {\n  test("expect socks not to be delicious", ({expect}) => {\n    expect.bool(isDelicious("socks")).toBeFalse();\n  });\n});\n')),Object(o.b)("h2",{id:"expectequal"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.equal")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonml"}),"type equalsFn('a) = ('a, 'a) => bool;\n\nlet expect = {\n  ...\n  equal: (~equals: equalsFn('a), 'a, 'a) => unit,\n  notEqual: (~equals: equalsFn('a), 'a, 'a) => unit,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectequalequals-a-a--bool-a-a"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.equal(~equals: ('a, 'a) => bool=?, 'a, 'a)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.equal(~equals=?, expected, actual)")," to check that two values are equal using ",Object(o.b)("inlineCode",{parentName:"p"},"=="),", a structural equality check. The negation of ",Object(o.b)("inlineCode",{parentName:"p"},"expect.equal")," is ",Object(o.b)("inlineCode",{parentName:"p"},"expect.notEqual")),Object(o.b)("p",null,"For example to structurally compare two records you could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonml"}),'open TestFramework;\n\ntype myType = {\n  string,\n  int,\n};\n\ndescribe("expect.equal", ({test}) => {\n  test("should be  equal", ({expect}) => {\n    expect.equal({string: "hello", int: 42}, {string: "hello", int: 42});\n  });\n});\n')),Object(o.b)("p",null,"Comparing types that need a custom comparator (such as records that contain floats) can also be done by providing a custom equals function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reasonml"}),'open TestFramework;\n\ntype myType = {\n  string,\n  float,\n};\n\ndescribe("expect.equal", ({test}) => {\n  test("should be  equal", ({expect}) => {\n    let equals = (t1, t2) =>\n      t1.string == t2.string && abs_float(t1.float -. t2.float) < 0.001;\n    expect.equal(\n      ~equals,\n      {string: "hello", float: 42.},\n      {string: "hello", float: 41.999999},\n    );\n  });\n});\n')),Object(o.b)("h2",{id:"expectext"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.ext")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"let expect('ext): {\n  ...\n  ext: 'ext\n  ...\n};\n")),Object(o.b)("h3",{id:"expectext-1"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.ext")),Object(o.b)("p",null,"You can add your own custom matchers to Rely. The matchers you define are available under the ext field of the expect record. Full documentation for writing and using custom matchers can be found ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/reason-native/docs/rely/api#custom-matchers"}),"here"),"."),Object(o.b)("h2",{id:"expectfile"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.file")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.file(filename)")," to make assertions about the contents of a file. ",Object(o.b)("inlineCode",{parentName:"p"},"expect.file")," provides the same API as ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#expectstring"}),Object(o.b)("inlineCode",{parentName:"a"},"expect.string"))," and handles the work of reading from the file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type stringMatchers = {\n  toBeEmpty: unit => unit,\n  toEqual: string => unit,\n  toEqualFile: string => unit,\n  toEqualLines: list(string) => unit,\n  toMatch: string => unit,\n};\ntype stringMatchersWithNot = {\n  not: stringMatchers,\n  toBeEmpty: unit => unit,\n  toEqual: string => unit,\n  toEqualFile: string => unit,\n  toEqualLines: list(string) => unit,\n  toMatch: string => unit,\n  toMatchSnapshot: unit => unit,\n};\n\nlet expect: {\n  ...\n  file: string => stringMatchersWithNot,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectfilestringtobeempty"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.file(string).toBeEmpty()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.file(filename).toBeEmpty")," to check that a file is empty."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My awesome app", ({test}) => {\n  test("error log should be empty", ({expect}) => {\n    MyApp.run();\n\n    expect.file("errorLog.txt").toBeEmpty();\n  });\n});\n')),Object(o.b)("h3",{id:"expectfilestringtoequalstring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.file(string).toEqual(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.file(filename).toEqual(expected)")," to check that the contents of a file are equal to some expected value."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Spaceballs", ({test}) => {\n  test("Interrogate Roland", ({expect}) => {\n    DarkHelmet.interrogate("Roland");\n\n    expect.file("password.txt").toEqual("12345");\n  });\n});\n')),Object(o.b)("h3",{id:"expectfilestringtoequalfilestring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.file(string).toEqualFile(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.file(actualFilename).toEqualFile(expectedFilename)")," to check that the contents of a file are equal to the contents of another file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Spaceballs", ({test}) => {\n  test("Passwords should match", ({expect}) => {\n    expect.file("DefenseShield/password.txt").toEqualFile("Skroob/luggagePassword.txt");\n  });\n});\n')),Object(o.b)("h3",{id:"expectfilestringtoequallinesliststring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.file(string).toEqualLines(list(string))")),Object(o.b)("p",null,"Use `expect.file(actualFilename).toEqualLines(expectedLines) to check that the contents of a file are equal a list of strings joined by a newline."),Object(o.b)("p",null,"For example if you wanted to write a program to generate a particular poem into a file called ",Object(o.b)("inlineCode",{parentName:"p"},"poem.txt"),", you could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Deep Thought", ({test}) => {\n  test("should write poetry", ({expect}) => {\n    let expected = [\n      "Roses are red",\n      "Violets are blue",\n      "Rely is great",\n      "Not false is true",\n    ];\n\n    DeepThought.writeSomePoetry();\n\n    expect.file("poem.txt").toEqualLines(expected);\n  });\n});\n')),Object(o.b)("h3",{id:"expectfilestringtomatchstring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.file(string).toMatch(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.file(actualFilename).toMatch(regex)")," to verify that a file matches a PCRE regex."),Object(o.b)("p",null,"For example if we want to verify that the file ",Object(o.b)("inlineCode",{parentName:"p"},"secretRecipe.txt")," contains either ",Object(o.b)("inlineCode",{parentName:"p"},"bacon")," or ",Object(o.b)("inlineCode",{parentName:"p"},"sausage")," I could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My recipe", ({test}) => {\n  test("should contain a cured pork product", ({expect}) => {\n    expect.file("secretRecipe.txt").toMatch("(bacon|sausage)");\n  });\n});\n')),Object(o.b)("h3",{id:"expectfilestringtomatchsnapshot"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.file(string).toMatchSnapshot()")),Object(o.b)("p",null,"This ensures that the file matches the most recent snapshot. To generate a new snapshot or update an old one you can run Rely via the command line and pass the ",Object(o.b)("inlineCode",{parentName:"p"},"-u")," flag."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My config generator", ({test}) => {\n  test("generate default config", ({expect}) => {\n    ConfigGenerator.generateDefaultConfig("test.json");\n    expect.file("test.json").toMatchSnapshot();\n  });\n});\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note that there is no ",Object(o.b)("inlineCode",{parentName:"p"},".not.toMatchSnapshot")," matcher.")),Object(o.b)("h2",{id:"expectfloat"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.float")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type floatMatchers = {toBeCloseTo: (~digits: int=?, float) => unit};\ntype floatMatchersWithNot = {\n  toBeCloseTo: (~digits: int=?, float) => unit,\n  not: floatMatchers,\n};\n\nlet expect: {\n  ...\n  float: float => floatMatchersWithNot,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectfloatfloattobeclosetodigits-int-float"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.float(float).toBeCloseTo(~digits: int=?, float)")),Object(o.b)("p",null,"Using exact equality with floating point numbers doesn't work in general. For example the following test fails:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("float equality", ({test}) => {\n  test("using expect.equals will cause this test to fail", ({expect}) => {\n    expect.equal(0.1 +. 0.2, 0.3);\n  });\n});\n')),Object(o.b)("p",null,"This fails because ",Object(o.b)("inlineCode",{parentName:"p"},"0.1 +. 0.2")," is equal to ",Object(o.b)("inlineCode",{parentName:"p"},"0.300000000000000044")," in Reason due to the underlying representation of floating point numbers."),Object(o.b)("p",null,"Instead, use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.float(actual).toBeCloseTo(~digits, expected)"),". For example, if you want to be sure that 0.2 + 0.1 is equal ot 0.3 with a precision of 5 decimal digits you can use this test:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("float equality", ({test}) => {\n  test("should pass with expect.float.toBeCloseTo", ({expect}) => {\n    expect.float(0.1 +. 0.2).toBeCloseTo(~digits=5, 0.3);\n  });\n});\n')),Object(o.b)("p",null,"The optional ",Object(o.b)("inlineCode",{parentName:"p"},"~digits")," argument has a default value of ",Object(o.b)("inlineCode",{parentName:"p"},"2"),". The exact criterion used is ",Object(o.b)("inlineCode",{parentName:"p"},"abs_float(actual -. expected) < (10 ** float_of_int(- digits)) /. 2.0"),". With the default value this translates to ",Object(o.b)("inlineCode",{parentName:"p"},"abs_float(actual -. expected) < 0.005")),Object(o.b)("h2",{id:"expectfn"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.fn")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type negatableFnMatchers = {toThrow: unit => unit};\ntype fnMatchersWithNot = {\n  not: negatableFnMatchers,\n  toThrow: unit => unit,\n  toThrowException: exn => unit,\n};\n\nlet expect: {\n  ...\n  fn: 'a. (unit => 'a) => fnMatchersWithNot\n  ...\n};\n")),Object(o.b)("h3",{id:"expectfnunit--atothrow"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.fn(unit => 'a).toThrow()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.fn(function).toThrow()")," to test that a function throws when it is called. For example, if we want to test that ",Object(o.b)("inlineCode",{parentName:"p"},'ToothpasteFactory.makeFlavor("duck")')," throws an exception because duck flavored toothpaste is too fowl, we could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("ToothpasteFactory", ({test}) => {\n  test("should throw an exception if asked to make bird flavored toothpaste", ({expect}) => {\n    expect.fn(() => ToothpasteFactory.makeFlavor("duck")).toThrow();\n  });\n});\n')),Object(o.b)("h3",{id:"expectfnunit--atothrowexceptionexn"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.fn(unit => 'a).toThrowException(exn)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.fn(function).toThrowException(exn)")," to test that a function throws a specific exception when it is called. For example if we want to test that dividing by zero throws a ",Object(o.b)("inlineCode",{parentName:"p"},"Division_by_zero")," exception we could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Arithmetic", ({test}) => {\n  test("should throw Division_by_zero when dividing by zero", ({expect}) => {\n    expect.fn(() => 1 / 0).toThrowException(Division_by_zero);\n  });\n});\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note that there is no expect.fn(unit => 'a).not.toThrowException(exn). It is encouraged to use expect.fn(unit => 'a).not.toThrow() rather than asserting that a particular exception was not thrown.")),Object(o.b)("h2",{id:"expectint"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.int")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type intMatchers = {toBe: int => unit};\ntype intMatchersWithNot = {\n  not: intMatchers,\n  toBe: int => unit,\n};\n\nlet expect: {\n  ...\n  int: intMatchersWithNot,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectintinttobeint"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.int(int).toBe(int)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.int(actual).toBe(expected)")," to check that an integer is equal to a particular value. For example if you expect Deep Thought to return ",Object(o.b)("inlineCode",{parentName:"p"},"42")," when asked to calculate the answer to the ultimate question, you could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.int.toBe", ({test}) => {\n  test("Calculate answer to the ultimate question", ({expect}) => {\n    let answer = DeepThought.answerUltimateQuestion();\n\n    expect.int(answer).toBe(42);\n  });\n});\n')),Object(o.b)("h2",{id:"expectlines"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.lines")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.lines(lines)")," to make assertions about lines of text. ",Object(o.b)("inlineCode",{parentName:"p"},"expect.lines")," provides the same API as ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#expectstring"}),Object(o.b)("inlineCode",{parentName:"a"},"expect.string"))," and compares against the result of ",Object(o.b)("inlineCode",{parentName:"p"},'String.concat("\\n", lines)'),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type stringMatchers = {\n  toBeEmpty: unit => unit,\n  toEqual: string => unit,\n  toEqualFile: string => unit,\n  toEqualLines: list(string) => unit,\n  toMatch: string => unit,\n};\ntype stringMatchersWithNot = {\n  not: stringMatchers,\n  toBeEmpty: unit => unit,\n  toEqual: string => unit,\n  toEqualFile: string => unit,\n  toEqualLines: list(string) => unit,\n  toMatch: string => unit,\n  toMatchSnapshot: unit => unit,\n};\n\nlet expect: {\n  ...\n  lines: list(string) => stringMatchersWithNot,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectlinesliststringtobeempty"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.lines(list(string)).toBeEmpty()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.lines(actual).toBeEmpty")," to check that a list of lines is empty."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Historical movies", ({test}) => {\n  test("the Charlie Chaplin movei should have no lines", ({expect}) => {\n    expect.lines(CharlieChaplinMovie.script).toBeEmpty();\n  });\n});\n')),Object(o.b)("h3",{id:"expectlinesliststringtoequalstring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.lines(list(string)).toEqual(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.lines(actual).toEqual(expected)")," to check that some lines of text are equal to an expected string."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Lines", ({test}) => {\n  test("to equal", ({expect}) => {\n    let greeting = [\n      "Hello",\n      "World"\n    ]\n\n    expect.lines(greeting).toEqual("Hello\\nWorld");\n  });\n});\n')),Object(o.b)("h3",{id:"expectlinesliststringtoequalfilestring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.lines(list(string)).toEqualFile(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.lines(actual).toEqualFile(filename)")," to check that the some lines are equal to the contents of a file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Deep Thought", ({test}) => {\n  test("should write poetry", ({expect}) => {\n    expect.lines(DeepThought.writeSomePoetry).toEqualFile("poem.txt");\n  });\n});\n')),Object(o.b)("h3",{id:"expectlinesliststringtoequallinesliststring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.lines(list(string)).toEqualLines(list(string))")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.lines(actual).toEqualLines(expected)")," to check that some lines are equal to another set of lines."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Deep Thought", ({test}) => {\n  test("should write poetry", ({expect}) => {\n    let expected = [\n      "Roses are red",\n      "Violets are blue",\n      "Rely is great",\n      "Not false is true",\n    ];\n\n    let actual = DeepThought.writeSomePoetry();\n\n    expect.lines(actual).toEqualLines(expected);\n  });\n});\n')),Object(o.b)("h3",{id:"expectlinesliststringtomatchstring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.lines(list(string)).toMatch(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.lines(actual).toMatch(regex)")," to verify that a file matches a PCRE regex."),Object(o.b)("p",null,"For example if we want to verify that the a recipe generator module generates a recipe that contains either ",Object(o.b)("inlineCode",{parentName:"p"},"bacon")," or ",Object(o.b)("inlineCode",{parentName:"p"},"sausage")," I could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My recipe", ({test}) => {\n  test("should contain a cured pork product", ({expect}) => {\n    let recipe = RecipeGenerator.makeRecipe();\n\n    expect.lines(recipe).toMatch("(bacon|sausage)");\n  });\n});\n')),Object(o.b)("h3",{id:"expectlinesliststringtomatchsnapshot"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.lines(list(string)).toMatchSnapshot()")),Object(o.b)("p",null,"This ensures that the lines matches the most recent snapshot. To generate a new snapshot or update an old one you can run Rely via the command line and pass the ",Object(o.b)("inlineCode",{parentName:"p"},"-u")," flag."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My config generator", ({test}) => {\n  test("generate default config", ({expect}) => {\n    let actual = ConfigGenerator.generateDefaultConfig();\n    expect.lines(actual).toMatchSnapshot();\n  });\n});\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note that there is no ",Object(o.b)("inlineCode",{parentName:"p"},".not.toMatchSnapshot")," matcher.")),Object(o.b)("h2",{id:"expectlist"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.list")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type equalsFn('a) = ('a, 'a) => bool;\n\ntype listMatchers('a) = {\n  toEqual: (~equals: equalsFn('a)=?, list('a)) => unit,\n  toBeEmpty: unit => unit,\n  toContain: 'a => unit,\n  toContainEqual: (~equals: equalsFn('a)=?, 'a) => unit,\n};\n\ntype listMatchersWithNot('a) = {\n  not: listMatchers('a),\n  toEqual: (~equals: equalsFn('a)=?, list('a)) => unit,\n  toBeEmpty: unit => unit,\n  toContain: 'a => unit,\n  toContainEqual: (~equals: equalsFn('a)=?, 'a) => unit,\n};\n\nlet expect: {\n  ...\n  list: 'a. list('a) => listMatchersWithNot('a),\n  ...\n};\n")),Object(o.b)("h3",{id:"expectlistlistatobeempty"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.list(list('a)).toBeEmpty()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.list(expected).toBeEmpty()")," to check that a list is empty."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.list.toBeEmpty", ({test}) => {\n  test("Empty list should be empty", ({expect}) => {\n    expect.list([]).toBeEmpty();\n  });\n});\n')),Object(o.b)("h3",{id:"expectlistlistatocontaina"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.list(list('a)).toContain('a)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.list(actual).toContain(expected)")," when you want to check that an item is in an list. For testing items in the list, this uses ",Object(o.b)("inlineCode",{parentName:"p"},"==="),", a physical equality check."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("list example", ({test}) => {\n  test("should contain", ({expect}) => {\n    expect.list([1, 2, 3]).toContain(2);\n  });\n});\n')),Object(o.b)("h3",{id:"expectlistlistatocontainequalequalsa-a--bool-a"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.list(list('a)).toContainEqual(~equals:('a, 'a) => bool=?, 'a)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.list(actual).toContainEqual(~equals=-?, 'a)")," when you want to check that an item is in an list. For testing items in the list, this uses ",Object(o.b)("inlineCode",{parentName:"p"},"==")," a structural equality check."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ntype insect = {\n  name: string,\n  numberOfLegs: int,\n};\n\ndescribe("list example", ({test}) => {\n  test("contain equal", ({expect}) => {\n    expect.list(getInsects()).toContainEqual({\n      name: "centipede",\n      numberOfLegs: 100,\n    });\n  });\n});\n')),Object(o.b)("p",null,"Comparing types that need a custom comparator (such as floats) can be done using ",Object(o.b)("inlineCode",{parentName:"p"},"expect.list(actual).toContainEqual"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\nlet equals = (f1, f2) => abs_float(f1 -. f2) < 0.1;\n\ndescribe("list example", ({test}) => {\n  test("contain equal", ({expect}) => {\n    expect.list([1., 2., 3.]).toContainEqual(~equals, 0.99);\n  });\n});\n')),Object(o.b)("h3",{id:"expectlistactualtoequalequals-expected"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.list(actual).toEqual(~equals, expected)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.list(actual).toEqual(~equals=?, expected)")," to check that an list is equal to another list."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("list example", ({test}) => {\n  test("list equality", ({expect}) => {\n    expect.list(countToThree()).toEqual([1, 2, 3]);\n  });\n});\n')),Object(o.b)("p",null,"Comparing lists of types that need a custom comparator (such as floats) can also be done."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\nlet equals = (f1, f2) => abs_float(f1 -. f2) < 0.1;\n\ndescribe("List example", ({test}) => {\n  test("toEqual with custom comparator", ({expect}) => {\n    expect.list(countToThreeWithFloats()).toEqual(~equals, [1., 2., 3.]);\n  });\n});\n')),Object(o.b)("h2",{id:"expectmock"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.mock")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type equalsFn('a) = ('a, 'a) => bool;\n\ntype negatableMockMatchers('tupledArgs, 'ret) = {\n  toThrow: unit => unit,\n  toBeCalled: unit => unit,\n  toBeCalledTimes: int => unit,\n  toBeCalledWith: (~equals: equalsFn('tupledArgs)=?, 'tupledArgs) => unit,\n  lastCalledWith: (~equals: equalsFn('tupledArgs)=?, 'tupledArgs) => unit,\n  nthCalledWith: (~equals: equalsFn('tupledArgs)=?, int, 'tupledArgs) => unit,\n  toReturnTimes: int => unit,\n  toReturnWith: (~equals: equalsFn('ret)=?, 'ret) => unit,\n  lastReturnedWith: (~equals: equalsFn('ret)=?, 'ret) => unit,\n  nthReturnedWith: (~equals: equalsFn('ret)=?, int, 'ret) => unit,\n};\n\ntype matchersWithNot('tupledArgs, 'ret) = {\n  not: negatableMockMatchers('tupledArgs, 'ret),\n  toThrow: unit => unit,\n  toThrowException: exn => unit,\n  toBeCalled: unit => unit,\n  toBeCalledTimes: int => unit,\n  toBeCalledWith: (~equals: equalsFn('tupledArgs)=?, 'tupledArgs) => unit,\n  lastCalledWith: (~equals: equalsFn('tupledArgs)=?, 'tupledArgs) => unit,\n  nthCalledWith: (~equals: equalsFn('tupledArgs)=?, int, 'tupledArgs) => unit,\n  toReturnTimes: int => unit,\n  toReturnWith: (~equals: equalsFn('ret)=?, 'ret) => unit,\n  lastReturnedWith: (~equals: equalsFn('ret)=?, 'ret) => unit,\n  nthReturnedWith: (~equals: equalsFn('ret)=?, int, 'ret) => unit,\n};\n\nlet expect: {\n  ...,\n  mock:\n  'fn 'ret 'tupledArgs.\n  Mock.t('fn, 'ret, 'tupledArgs) => matchersWithNot('tupledArgs, 'ret),\n  ...\n};\n")),Object(o.b)("h3",{id:"expectmockmocklastcalledwithargs"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).lastCalledWith('args)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).lastCalledWith(args)")," to test what arguments a mock function was last called with."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Mock matchers", ({test}) => {\n  test("lastCalledWith", ({expect}) => {\n    let mock = Mock.mock1(a => a);\n    let mockFn = Mock.fn(mock);\n\n    let _ = mockFn(1);\n    let _ = mockFn(2);\n\n    expect.mock(mock).lastCalledWith(2);\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocklastreturnedwithret"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).lastReturnedWith('ret)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).lastCalledWith(args)")," to test what arguments a mock function was last called with."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Mock matchers", ({test}) => {\n  test("lastCalledWith", ({expect}) => {\n    let mock = Mock.mock1(n => 2 * n);\n    let mockFn = Mock.fn(mock);\n\n    let _ = mockFn(1);\n    let _ = mockFn(2);\n\n    expect.mock(mock).lastReturnedWith(4);\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocknthcalledwithequalsargs-args--bool-int-args"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).nthCalledWith(~equals:('args, 'args) => bool=?, int, 'args)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).nthCalledWith(~equals=?, n, expected)")," to test what arguments a mock function was called with for its nth call. For example suppose that you are implementing ",Object(o.b)("inlineCode",{parentName:"p"},"map")," for some data structure and want to verify that the function is called based on the order elements are added to the structure. You can write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map calls the passed in function in the order elements are added", ({expect}) => {\n    let double = x => x * 2;\n    /*there are constructors for up to 7 args */\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(10) |> MyStructure.add(50);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).nthCalledWith(1, 10);\n    expect.mock(mock).nthCalledWith(2, 50);\n  });\n});\n')),Object(o.b)("p",null,"For dealing with floats or other situations in which custom equality is required, a custom equals function can be provided:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map calls the passed in function in the order elements are added", ({expect}) => {\n    let double = x => x *. 2.;\n    let equals = (a, b) => abs_float(a -. b) < 0.1;\n\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(10.) |> MyStructure.add(50.);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).nthCalledWith(~equals, 1, 10.);\n    expect.mock(mock).nthCalledWith(~equals, 2, 50.);\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocknthreturnedwithequalsret-ret--bool-int-args"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).nthReturnedWith(~equals:('ret, 'ret) => bool=?, int, 'args)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).nthReturnedWith(~equals=?, n, expected)")," to test the specific value that a mock function returned for the nth call. For example suppose that you are implementing ",Object(o.b)("inlineCode",{parentName:"p"},"map")," for some data structure and want to verify that the function is called based on the order elements are added to the structure. You can write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map calls the passed in function in the order elements are added", ({expect}) => {\n    let double = x => x * 2;\n    /*there are constructors for up to 7 args */\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(10) |> MyStructure.add(50);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).nthReturnedWith(1, 20);\n    expect.mock(mock).nthReturnedWith(2, 100);\n  });\n});\n')),Object(o.b)("p",null,"For dealing with floats or other situations in which custom equality is required, a custom equals function can be provided:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map calls the passed in function in the order elements are added", ({expect}) => {\n    let double = x => x *. 2.;\n    let equals = (a, b) => abs_float(a -. b) < 0.1;\n\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(10.) |> MyStructure.add(50.);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).nthReturnedWith(~equals, 1, 20.);\n    expect.mock(mock).nthReturnedWith(~equals, 2, 100.);\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocktobecalled"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).toBeCalled()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).toBeCalled")," to ensure that a mock function got called."),Object(o.b)("p",null,"For example suppose that you are implementing ",Object(o.b)("inlineCode",{parentName:"p"},"map")," for some data structure and want to verify that the function argument to map is actually called on a non empty structure. To test this, you could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map actually uses the passed in function", ({expect}) => {\n    let double = x => x * 2;\n    /*there are constructors for up to 7 args */\n    let mock = Mock.mock1(double);\n\n    let myStructure = MyStructure.empty |> MyStructure.add(1);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).toBeCalled();\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocktobecalledtimesint"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).toBeCalledTimes(int)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).toBeCalledTimes(int)")," to ensure that a mock function got called a certain number of times."),Object(o.b)("p",null,"For example suppose that you are implementing ",Object(o.b)("inlineCode",{parentName:"p"},"map")," for some data structure and want to verify that the function argument to map is called once per element in the structure. To test this, you could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map calls the passed in function once per argument", ({expect}) => {\n    let double = x => x * 2;\n    /*there are constructors for up to 7 args */\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(1) |> MyStructure.add(2);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).toBeCalledTimes(2);\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocktobecalledwithequals-args-args--bool-args"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).toBeCalledWith(~equals: ('args, 'args) => bool=?, 'args)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).toBeCalledWith(~equals=?, args)")," to ensure that a mock function got called with particular arguments."),Object(o.b)("p",null,"For example suppose that you are implementing ",Object(o.b)("inlineCode",{parentName:"p"},"map")," for some data structure and want to verify that for a data structure with one element, the function passed to map is called with the value of that element."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map actually uses the passed in function", ({expect}) => {\n    let double = x => x * 2;\n    /*there are constructors for up to 7 args */\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(1);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).toBeCalledWith(1);\n  });\n});\n')),Object(o.b)("p",null,"For dealing with floats or other situations in which custom equality is required, a custom equals function can be provided:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'describe("My data structure", ({test}) => {\n  test("map actually uses the passed in function", ({expect}) => {\n    let equals = (f1, f2) => abs_float(f1 -. f2) < 0.1;\n    let double = x => x *. 2.;\n\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(1.);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).toBeCalledWith(~equals, 1.);\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocktothrow"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).toThrow()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).toThrow()")," to ensure that the implementation of a mock function has thrown during at least one of its invocations."),Object(o.b)("p",null,"For example, if we want to test that our program can successfully handle a callback that raises an error, we could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\nexception MyException;\n\ndescribe("my program", ({test}) => {\n  test("should gracefully handle an error raised by a callback", ({expect}) => {\n    let mock = Mock.mock1(_ => raise(MyException));\n    /* ensure that our program runs without throwing an exception */\n    expect.fn(() => MyProgram.run(Mock.fn(mock)).not.toThrow();\n    /* ensure that our callback was called and did throw an exception*/\n    expect.mock(mock).toThrow();\n  });\n});\n\n')),Object(o.b)("h3",{id:"expectmockmocktothrowexceptionexn"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).toThrowException(exn)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).toThrowException(exn)")," to ensure that the implementation of a mock function has thrown a particular exception during at least one of its invocations."),Object(o.b)("p",null,"For example, suppose we have a shipping logistics application that accepts a shipping strategy of type ",Object(o.b)("inlineCode",{parentName:"p"},"(weight, location) => unit")," and we want to verify that our ",Object(o.b)("inlineCode",{parentName:"p"},"byCarrierPigeon")," strategy throws a ",Object(o.b)("inlineCode",{parentName:"p"},"TooHeavy")," exception when asked to ship a grand piano."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My Shipping app", ({test}) => {\n  test("can\'t ship a grand piano by carrier pigeon", ({expect}) => {\n    let mock = Mock.mock2(ShippingStrategies.byCarrierPigeon);\n\n    MyShippingApp.ship(Items.grandPiano, Mock.fn(mock));\n\n    expect.mock(mock).toThrowException(TooHeavy);\n  });\n});\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note that there is no expect.mock(mock).not.toThrowException(exn). It is encouraged to use expect.mock(mock).not.toThrow() rather than asserting that a particular exception was not thrown.")),Object(o.b)("h3",{id:"expectmockmocktoreturntimesint"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).toReturnTimes(int)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).toReturnTimes(numTimes)")," to ensure that a mock function returned successfully (i.e. did not throw an error) an exact number of times. Any calls to the mock function that throw an exception are not counted toward the number of times the function returned."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.mock.toReturnTimes", ({test}) => {\n  test("Mock returns twice", ({expect}) => {\n    let mock = Mock.mock1(_ => ());\n\n    let mockFunction = Mock.fn(mock);\n\n    let _ = mockFunction();\n    let _ = mockFunction();\n\n    expect.mock(mock).toReturnTimes(2);\n  });\n});\n')),Object(o.b)("h3",{id:"expectmockmocktoreturnwithequals-ret-ret--bool-ret"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.mock(mock).toReturnWith(~equals: ('ret, 'ret) => bool=?, 'ret)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.mock(mock).toReturnWith(~equals=?, expected)")," to ensure that a mock function has returned at least once with a specific value."),Object(o.b)("p",null,"For example suppose that you are implementing ",Object(o.b)("inlineCode",{parentName:"p"},"map")," for some data structure and want to verify that when passing the function ",Object(o.b)("inlineCode",{parentName:"p"},"double")," to ",Object(o.b)("inlineCode",{parentName:"p"},"map")," on a structure containing ",Object(o.b)("inlineCode",{parentName:"p"},"1"),", ",Object(o.b)("inlineCode",{parentName:"p"},"2")," will be returned."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My data structure", ({test}) => {\n  test("map actually uses the passed in function", ({expect}) => {\n    let double = x => x * 2;\n    /*there are constructors for up to 7 args */\n    let mock = Mock.mock1(double);\n\n    let myStructure = MyStructure.empty |> MyStructure.add(1);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).toReturnWith(2);\n  });\n});\n')),Object(o.b)("p",null,"For dealing with floats or other situations in which custom equality is required, a custom equals function can be provided:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'describe("My data structure", ({test}) => {\n  test("map actually uses the passed in function", ({expect}) => {\n    let equals = (f1, f2) => abs_float(f1 -. f2) < 0.1;\n    let double = x => x *. 2.;\n\n    let mock = Mock.mock1(double);\n\n    let myStructure =\n      MyStructure.empty |> MyStructure.add(1.);\n\n    let _ = MyStructure.map(Mock.fn(mock), myStructure);\n\n    expect.mock(mock).toReturnWith(~equals, 2.);\n  });\n});\n')),Object(o.b)("h2",{id:"expectoption"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.option")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type equalsFn('a) = ('a, 'a) => bool;\n\ntype optionMatchers('a) = {\n  toBeNone: unit => unit,\n  toBeSome: unit => unit,\n  toBe: (~equals: equalsFn('a)=?, option('a)) => unit,\n};\n\ntype optionMatchersWithNot('a) = {\n  not: optionMatchers('a),\n  toBeNone: unit => unit,\n  toBeSome: unit => unit,\n  toBe: (~equals: equalsFn('a)=?, option('a)) => unit,\n};\n\nlet expect: {\n  ...\n  option: 'a. option('a) => optionMatchersWithNot('a),\n  ...\n};\n")),Object(o.b)("h3",{id:"expectoptionatobeequals-a-a--bool-optiona"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.option('a).toBe(~equals: ('a, 'a) => bool=?, option('a))")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.option(actual).toBe(~equals=?, expected)")," to test the value of an option."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.option.toBe", ({test}) => {\n  test("Deep thought should compute the ultimate answer", ({expect}) => {\n    let answer = DeepThought.answerUltimateQuestion();\n\n    expect.option(answer).toBe(Some(42));\n  });\n\n  test("Custom equality", ({expect}) => {\n    let equals = (f1, f2) => f1 -. f2 < 0.001;\n    expect.option(Some(1.)).toBe(~equals, Some(1.000001));\n  });\n});\n')),Object(o.b)("h3",{id:"expectoptionoptionatobenone"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.option(option('a)).toBeNone()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.option(actual).toBeNone()")," to test that the value of an option is equal to ",Object(o.b)("inlineCode",{parentName:"p"},"None"),";"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.option.toBeNone", ({test}) => {\n  test("shouldn\'t be anything better than bacon for breakfast", ({expect}) => {\n    let result = BreakfastFoodRanker.findSuperiorOptionTo("bacon");\n\n    expect.option(result).toBeNone();\n  });\n});\n')),Object(o.b)("h3",{id:"expectoptionoptionatobesome"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.option(option('a)).toBeSome()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.option(actual).toBeSome()")," to test that the value of an option is not equal to ",Object(o.b)("inlineCode",{parentName:"p"},"None"),". This is equivalent to ",Object(o.b)("inlineCode",{parentName:"p"},"expect.option(actual).not.toBeNone()"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.option.toBeNone", ({test}) => {\n  test("should be something better than octopus for breakfast", ({expect}) => {\n    let result = BreakfastFoodRanker.findSuperiorOptionTo("octopus");\n\n    expect.option(result).toBeSome();\n  });\n});\n')),Object(o.b)("h2",{id:"expectresult"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.result")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type equalsFn('a) = ('a, 'a) => bool;\n\ntype resultMatchers('a, 'b) = {\n  toBeOk: unit => unit,\n  toBeError: unit => unit,\n  toBe:\n    (\n      ~equalsOk: equalsFn('a)=?,\n      ~equalsError: equalsFn('b)=?,\n      result('a, 'b)\n    ) =>\n    unit,\n};\n\ntype resultMatchersWithNot('a, 'b) = {\n  not: resultMatchers('a, 'b),\n  toBeOk: unit => unit,\n  toBeError: unit => unit,\n  toBe:\n    (\n      ~equalsOk: equalsFn('a)=?,\n      ~equalsError: equalsFn('b)=?,\n      result('a, 'b)\n    ) =>\n    unit,\n};\n\nlet expect: {\n  ...\n  result: 'a 'b. result('a, 'b) => resultMatchersWithNot('a, 'b),\n  ...\n};\n")),Object(o.b)("h3",{id:"expectresultresultatobeequalsok-a-a--bool-equalserror-b-b--bool--resulta"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.result(result('a)).toBe(~equalsOk: ('a, 'a) => bool=?, ~equalsError: ('b, 'b) => bool =?, result('a))")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.result(actual).toBe(~equalsOk=?, ~equalsError=?, expected)")," to test the value of a result. The optional ",Object(o.b)("inlineCode",{parentName:"p"},"~equalsOk")," and ",Object(o.b)("inlineCode",{parentName:"p"},"~equalsError"),"can be used when comparing values for which the default ",Object(o.b)("inlineCode",{parentName:"p"},"=="),"is insufficient, such as with floats."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.result.toBe", ({test}) => {\n  test("Deep thought should compute the ultimate answer", ({expect}) => {\n    let answer = DeepThought.answerUltimateQuestion();\n\n    expect.option(answer).toBe(Ok(42));\n  });\n\n  test("Custom equality", ({expect}) => {\n    let equals = (f1, f2) => f1 -. f2 < 0.001;\n    expect.option(Some(1.)).toBe(~equalsOk=equals, Some(1.000001));\n    expect.option(Error(1.)).toBe(~equalsError=equals, Error(1.000001));\n  });\n});\n')),Object(o.b)("h3",{id:"expectresultresultatobeok"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.result(result('a)).toBeOk()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.option(actual).toBeNone()")," to test that the value of a result matches the ",Object(o.b)("inlineCode",{parentName:"p"},"Ok")," constructor."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.option.toBeOk", ({test}) => {\n  test("Car should be able to find directions to Disney World", ({expect}) => {\n    let result = Car.navigate("Disney World");\n\n    expect.option(result).toBeOk();\n  });\n});\n')),Object(o.b)("h3",{id:"expectresultresultatobeerror"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.result(result('a)).toBeError()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.option(actual).toBeNone()")," to test that the value of a result matches the ",Object(o.b)("inlineCode",{parentName:"p"},"Error")," constructor."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.option.toBeError", ({test}) => {\n  test("Car should not be able to find directions to the moon", ({expect}) => {\n    let result = Car.navigate("the moon");\n\n    expect.option(result).toBeError();\n  });\n});\n')),Object(o.b)("h2",{id:"expectsame"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.same")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"let expect: {\n  ...\n  same: 'a. ('a, 'a) => unit,\n  notSame: 'a. ('a, 'a) => unit,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectsamea-a"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.same('a, 'a)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.same(expected, actual)")," to check that two values are equal using ",Object(o.b)("inlineCode",{parentName:"p"},"==="),", a physical equality check."),Object(o.b)("h3",{id:"expectnotsamea-a"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.notSame('a, 'a)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.notSame(expected, actual)")," to check that two values are not equal using ",Object(o.b)("inlineCode",{parentName:"p"},"==="),", a physical equality check."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ntype person = {\n  name: string,\n  age: int,\n};\n\ndescribe("expect.notSame", ({test}) => {\n  test("two different people with the same name and age should not be the same", ({expect}) => {\n    expect.notSame(\n      {name: "Alan Turing", age: 41},\n      {name: "Alan Turing", age: 41},\n    );\n  });\n});\n')),Object(o.b)("h2",{id:"expectstring"},Object(o.b)("inlineCode",{parentName:"h2"},"expect.string")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),"type stringMatchers = {\n  toBeEmpty: unit => unit,\n  toEqual: string => unit,\n  toEqualFile: string => unit,\n  toEqualLines: list(string) => unit,\n  toMatch: string => unit,\n};\ntype stringMatchersWithNot = {\n  not: stringMatchers,\n  toBeEmpty: unit => unit,\n  toEqual: string => unit,\n  toEqualFile: string => unit,\n  toEqualLines: list(string) => unit,\n  toMatch: string => unit,\n  toMatchSnapshot: unit => unit,\n};\n\nlet expect: {\n  ...\n  string: string => stringMatchersWithNot,\n  ...\n};\n")),Object(o.b)("h3",{id:"expectstringstringtobeempty"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.string(string).toBeEmpty()")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.string(actual).toBeEmpty()")," to check that a string is empty."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("expect.string.toBeEmpty", ({test}) => {\n  test("empty string should be empty", ({expect}) => {\n    expect.string("").toBeEmpty();\n  });\n});\n')),Object(o.b)("h3",{id:"expectstringstringtoequalstring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.string(string).toEqual(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.string(actual).toEqual(expected)")," to test that a string is equal to a particular value."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Greeter", ({test}) => {\n  test("greeting should be Hello World!", ({expect}) => {\n    expect.string(Greeter.greeting).toEqual("Hello World!");\n  });\n});\n')),Object(o.b)("h3",{id:"expectstringstringtoequalfilestring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.string(string).toEqualFile(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.string(actual).toEqualFile(filename)")," to check that a string is equal to the contents of a file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Spaceballs", ({test}) => {\n  test("Password should be 12345", ({expect}) => {\n    expect.string("12345").toEqualFile("DefenseShield/password.txt");\n  });\n});\n')),Object(o.b)("h3",{id:"expectstringstringtoequallinesliststring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.string(string).toEqualLines(list(string))")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.string(actual).toEqualLines(expected)")," to check that a string is equal to a list of strings joined by a new line."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("Deep Thought", ({test}) => {\n  test("should write poetry", ({expect}) => {\n    let expected = [\n      "Roses are red",\n      "Violets are blue",\n      "Rely is great",\n      "Not false is true",\n    ];\n\n    let actual = DeepThought.writeSomePoetry();\n\n    expect.string(actual).toEqualLines(expected);\n  });\n});\n')),Object(o.b)("h3",{id:"expectstringstringtomatchstring"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.string(string).toMatch(string)")),Object(o.b)("p",null,"Use ",Object(o.b)("inlineCode",{parentName:"p"},"expect.string(actual).toMatch(regex)")," to verify that a string matches a PCRE regex."),Object(o.b)("p",null,"For example if we want to verify that the a recipe generator module generates a recipe that contains either ",Object(o.b)("inlineCode",{parentName:"p"},"bacon")," or ",Object(o.b)("inlineCode",{parentName:"p"},"sausage")," I could write:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My recipe", ({test}) => {\n  test("should contain a cured pork product", ({expect}) => {\n    let recipe = RecipeGenerator.makeRecipe();\n\n    expect.string(recipe).toMatch("(bacon|sausage)");\n  });\n});\n')),Object(o.b)("h3",{id:"expectstringstringtomatchsnapshot"},Object(o.b)("inlineCode",{parentName:"h3"},"expect.string(string).toMatchSnapshot()")),Object(o.b)("p",null,"This ensures that the string matches the most recent snapshot. To generate a new snapshot or update an old one you can run Rely via the command line and pass the ",Object(o.b)("inlineCode",{parentName:"p"},"-u")," flag."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason"}),'open TestFramework;\n\ndescribe("My config generator", ({test}) => {\n  test("generate default config", ({expect}) => {\n    let actual = ConfigGenerator.generateDefaultConfig();\n    expect.string(actual).toMatchSnapshot();\n  });\n});\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note that there is no ",Object(o.b)("inlineCode",{parentName:"p"},".not.toMatchSnapshot")," matcher.")))}p.isMDXComponent=!0},121:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),o=n.n(a);function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){c(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),p=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r({},t,{},e)),n},u=function(e){var t=p(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},b="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,c=e.originalType,l=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),u=p(n),b=a,m=u["".concat(l,".").concat(b)]||u[b]||d[b]||c;return n?o.a.createElement(m,r({ref:t},s,{components:n})):o.a.createElement(m,r({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var c=n.length,l=new Array(c);l[0]=m;var r={};for(var i in t)hasOwnProperty.call(t,i)&&(r[i]=t[i]);r.originalType=e,r[b]="string"==typeof e?e:a,l[1]=r;for(var s=2;s<c;s++)l[s]=n[s];return o.a.createElement.apply(null,l)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);